package ddl

// Code generated by go generate; DO NOT EDIT.

import (
	"bytes"
)

%%{
	machine foreign_key;
	write data;
}%%

func ParseForeignKey(data string) (*ForeignKey, error) {
	fk := &ForeignKey{}

	buffer := &bytes.Buffer{}
	cs, eof := 0, len(data);
	p, pe := 0, eof;
	%%{

	action addToBuffer       {
		buffer.WriteByte(fc)
	}

	action addColumn {
		fk.addColumn(buffer.String())
		buffer.Reset()
	}
	action addReferenced {
		fk.addReferenced(buffer.String())
		buffer.Reset()
	}
	action setMatch {
		fk.setMatch(buffer.String())
		buffer.Reset()
	}
	action setOnDelete {
		fk.setOnDelete(buffer.String())
		buffer.Reset()
	}
	action setOnUpdate {
		fk.setOnUpdate(buffer.String())
		buffer.Reset()
	}
	action setTable {
		fk.setTable(buffer.String())
		buffer.Reset()
	}

	action matchDeferrable        { fk.Deferrable = true }
	action matchInitiallyDeferred { fk.InitiallyDeferred = true }

	ws = space+;
	ident = [a-zA-Z][_a-zA-Z0-9]*;
	match = ( 'FULL'i | 'PARTIAL'i | 'SIMPLE'i );
	onaction = ( 'NO'i ws 'ACTION'i | 'RESTRICT'i | 'CASCADE'i | 'SET'i ws 'NULL'i | 'SET'i ws 'DEFAULT'i );

	main := space*
		'FOREIGN'i ws 'KEY'i ws '(' ws?
		  ( ident $ addToBuffer % addColumn )
		  ( ws? ',' ws? ( ident $ addToBuffer % addColumn ) )*
		ws? ')'
		ws 'REFERENCES'i ws ( ident $ addToBuffer % setTable ) '(' ws?
		  ( ident $ addToBuffer % addReferenced )
		  ( ws? ',' ws? ( ident $ addToBuffer % addReferenced ) )*
		ws? ')'
		( ws 'MATCH'i ws ( match $ addToBuffer % setMatch ) )?
		( ws 'ON'i ws 'DELETE'i ws ( onaction $ addToBuffer % setOnDelete ) )?
		( ws 'ON'i ws 'UPDATE'i ws ( onaction $ addToBuffer % setOnUpdate ) )?
		( ws ( 'NOT'i ws 'DEFERRABLE'i )
		| ws ( 'DEFERRABLE'i ws @ matchDeferrable )?
		  ( 'INITIALLY'i ws 'IMMEDIATE'i
		  | 'INITIALLY'i ws 'DEFERRED'i @ matchInitiallyDeferred
		  )?
		)?
		space*
		;

	write init;
	write exec;
	}%%

	if cs < foreign_key_first_final {
		return nil, &parseError{
		    cs: cs,
		    data: data,
		}
	}

	return fk, nil
}
