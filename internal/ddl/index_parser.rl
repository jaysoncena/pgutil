package ddl

// Code generated by go generate; DO NOT EDIT.

import (
	"bytes"
)

%%{
	machine index;
	write data;
}%%

func ParseIndex(data string) (*Index, error) {
	index := &Index{}

	buffer := &bytes.Buffer{}
	cs, eof, p, pe := 0, len(data), 0, len(data)
	%%{

	action addToBuffer       {
		buffer.WriteByte(fc)
	}

	action addColumn {
		index.addColumn(buffer.String())
		buffer.Reset()
	}
	action addExpression {
		index.addExpression(buffer.String())
		buffer.Reset()
	}
	action setName {
		index.setName(buffer.String())
		buffer.Reset()
	}
	action setOpClass {
		index.setOpClass(buffer.String())
		buffer.Reset()
	}
	action setTable {
		index.setTable(buffer.String())
		buffer.Reset()
	}
	action setUsing {
		index.setUsing(buffer.String())
		buffer.Reset()
	}
	action setWhere {
		index.setWhere(buffer.String())
		buffer.Reset()
	}

	action matchUnique   { index.Unique = true }

	ws = space+;
	expr = '(' [^)]+ ')';
	fncall = [a-zA-Z][_a-zA-Z0-9]* '(' [^)]* ')';
	ident = [a-zA-Z][_a-zA-Z0-9]*;

	main := space*
		'CREATE'i ws ( 'UNIQUE'i @ matchUnique ws )?  'INDEX'i
		ws ( ident $ addToBuffer % setName )
		ws 'ON'i ws ( ident $ addToBuffer % setTable )
		(ws 'USING'i ws ( ident $ addToBuffer % setUsing ))?
		ws '(' ws?
		  ( expr $ addToBuffer % addExpression
		  | fncall $ addToBuffer % addExpression
		  | ident $ addToBuffer % addColumn
		  )
		  (ws ident $ addToBuffer % setOpClass )?
		  ( ws? ',' ws? ( ident $ addToBuffer % addColumn )
		    (ws ident $ addToBuffer % setOpClass )?
		  )*
		ws? ')'
		(ws 'WHERE'i ws ( any+ $ addToBuffer % setWhere )
		| space* )
		;

	write init;
	write exec;
	}%%

	if cs < index_first_final {
		return nil, &parseError{
		    cs: cs,
		    data: data,
		}
	}

	return index, nil
}
