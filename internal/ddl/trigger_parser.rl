package ddl

// Code generated by go generate; DO NOT EDIT.

import (
	"bytes"
	"strings"
)

%%{
	machine trigger;
	write data;
}%%

func ParseTrigger(data string) (*Trigger, error) {
	trigger := &Trigger{}

	buffer := &bytes.Buffer{}
	cs, p, pe, eof := 0, 0, len(data), -1
	%%{
	action buffer_fc       {
		buffer.WriteByte(fc)
	}
	action match_constraint   { trigger.Constraint = true }
	action set_called {
		trigger.Called = strings.ToUpper(
			collapseWhitespace(buffer.String()),
		)
		buffer.Reset()
	}
	action set_event {
		trigger.Events = []*TriggerEvent{
			{Event: strings.ToUpper(
				buffer.String(),
			)},
		}
		buffer.Reset()
	}
	action add_event {
		trigger.Events = append(trigger.Events,
			&TriggerEvent{Event: strings.ToUpper(
				buffer.String(),
			)},
		)
		buffer.Reset()
	}
	action set_name {
		trigger.Name = buffer.String()
		buffer.Reset()
	}
	action set_table {
		trigger.Table = buffer.String()
		buffer.Reset()
	}

	ws = space+;
	ident = [a-zA-Z][_a-zA-Z0-9]*;

	main := space*
		'CREATE'i ws ( 'CONSTRAINT'i@match_constraint ws )?  'TRIGGER'i
		ws ( ident $ buffer_fc % set_name )
		ws ( ('BEFORE'i | 'AFTER'i | ('INSTEAD'i ws 'OF'i)) $ buffer_fc % set_called )
		ws ( ('DELETE'i | 'INSERT'i | 'TRUNCATE'i | 'UPDATE'i) $ buffer_fc % set_event )
		(ws 'OR'i ws ( ('DELETE'i | 'INSERT'i | 'TRUNCATE'i | 'UPDATE'i) $ buffer_fc % add_event ))*
		ws 'ON'i ws ( ident $ buffer_fc % set_table )
		space*
		;

	write init;
	write exec;
	}%%

	if cs < trigger_first_final {
		return nil, &parseError{
		    cs: cs,
		    data: data,
		}
	}

	return trigger, nil
}
