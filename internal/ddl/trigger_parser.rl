package ddl

// Code generated by go generate; DO NOT EDIT.

import (
	"bytes"
)

%%{
	machine trigger;
	write data;
}%%

func ParseTrigger(data string) (*Trigger, error) {
	trigger := &Trigger{}

	buffer := &bytes.Buffer{}
	cs, p, pe, eof := 0, 0, len(data), -1
	%%{
	action buffer_fc       {
		buffer.WriteByte(fc)
	}
	action match_constraint   { trigger.Constraint = true }
	action set_called {
		trigger.setCalled(buffer.String())
		buffer.Reset()
	}
	action add_event {
		trigger.addEvent(buffer.String())
		buffer.Reset()
	}
	action set_for_each {
		trigger.setForEach(buffer.String())
		buffer.Reset()
	}
	action set_name {
		trigger.setName(buffer.String())
		buffer.Reset()
	}
	action set_table {
		trigger.setTable(buffer.String())
		buffer.Reset()
	}
	action set_timing {
		trigger.setTiming(buffer.String())
		buffer.Reset()
	}

	ws = space+;
	ident = [a-zA-Z][_a-zA-Z0-9]*;

	main := space*
		'CREATE'i ws ( 'CONSTRAINT'i@match_constraint ws )?  'TRIGGER'i
		ws ( ident $ buffer_fc % set_name )
		ws ( ('BEFORE'i | 'AFTER'i | ('INSTEAD'i ws 'OF'i)) $ buffer_fc % set_called )
		ws ( ('DELETE'i | 'INSERT'i | 'TRUNCATE'i | 'UPDATE'i) $ buffer_fc % add_event )
		( ws 'OR'i ws ( ('DELETE'i | 'INSERT'i | 'TRUNCATE'i | 'UPDATE'i) $ buffer_fc % add_event ))*
		ws 'ON'i ws ( ident $ buffer_fc % set_table )
		( ws (('NOT'i ws 'DEFERRABLE'i) $ buffer_fc % set_timing )
		| ws ('DEFERRABLE'i ws)? ( ('INITIALLY'i ws 'DEFERRED'i | 'INITIALLY'i ws 'IMMEDIATE'i) $ buffer_fc % set_timing )
		)?
		( ws 'FOR'i ws ('EACH'i ws)? (('ROW'i | 'STATEMENT'i) $ buffer_fc % set_for_each ))?
		space*
		;

	write init;
	write exec;
	}%%

	if cs < trigger_first_final {
		return nil, &parseError{
		    cs: cs,
		    data: data,
		}
	}

	return trigger, nil
}
